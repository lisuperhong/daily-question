### 4.19

NFC工作模式有几种，对应的使用场景？

- 读卡器模式：将NFC设备当做读卡器，可以读取有NFC芯片的标签、贴纸里面的信息，可以向这些标签和贴纸写入信息。通常NFC标签是不需要外部供电的，当NFC设备向标签读取数据时，它会发送某种磁场，这个磁场会自动的向NFC标签供电
- 仿真卡模式：将支持NFC的手机或其他电子设备当成借记卡、公交卡、门禁卡等IC卡使用。原理是将IC卡中的信息凭证分分钟成数据包存储在支持NFC的外设中，在使用时需要一个NFC射频器（相当于刷卡器），将手机靠近NFC射频器，手机就会接收到NFC射频器发过来的信号，在通过一系列复杂的验证后，将IC卡的相应信息传入NFC射频器，最后这些IC卡数据会传入NFC射频器连接的电脑，并进行相应的处理（如电子转帐、开门等操作）
- 点对点模式：用于不同NFC设备之间进行数据交换，不过这个模式已经没有有“刷”的感觉了。其有效距离一般不能超过4厘米，但传输建立速度要比红外和蓝牙技术快很多，传输速度比红外快得多，如双方都使用Android4.2，NFC会直接利用蓝牙传输。这种技术被称为AndroidBeam，所以使用androidBeam传输数据的两部设备不再限于4厘米之内



### 4.20

调用Thread.sleep()为什么要抛出InterruptedException异常？

当一个方法后面声明可能会抛出InterruptedException 异常时，说明该方法是可能会花一点时间，但是可以取消的方法；执行sleep方法的线程，会暂停执行参数内所设置的时间，而需要花时间的操作会降低程序的响应性，所以可能会取消/中途放弃执行这个方法(主要是通过interrupt方法来取消)。interrupt方法本质上不会进行线程的终止操作，它不过是改变了线程的中断状态。而改变了此状态带来的影响是，部分可阻塞线程的方法（比如Object.wait, Thread.sleep）会定期执行isInterrupted方法，检测到此变化，随后会立即停止阻塞并抛出InterruptedException异常，从而catch块获得线程的控制权



### 4.21

Intent最大传递数据有限制吗？限制是多少？如有限制，有什么好的方案传输数据？

限制最大为1M，Intent 传输数据的机制中，用到了 Binder。Intent 中的数据，会作为 Parcel 被存储在 Binder 的事务缓冲区(Binder transaction buffer)中并对对象进行传输。而这个 **Binder 事务缓冲区具有一个有限的固定大小，当前为 1MB**；Intent 使用 Bundle 存储数据，是值传递(深拷贝)方式。在 Android 中，使用 Bundle 传输数据，并非 Intent 独有的。例如使用弹窗时，DialogFragment 中也可以通过 `setArguments(Bundle)` 传递一个 Bundle 对象给对话框。Fragment 本身是不涉及跨进程的，这里虽然使用了 Bundle 传输数据，但是并没有通过 Binder，也就是不存在序列化和反序列化，和 Fragment 数据传递相关的 Bundle，其实传递的是原对象的引用。

可以使用EventBus的粘性事件来传递大数据




--------------------- 